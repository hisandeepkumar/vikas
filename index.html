<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Multi-Thumbnail Generator (Fast, Free & Secure)</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+Devanagari:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <style>
    /* (Keep all the existing CSS styles) */
    /* ... */
  </style>
</head>
<body>
  <!-- (Keep all the existing HTML structure) -->
  <!-- ... -->
  
  <script>
    // (Keep all the existing JavaScript code until the generateThumbnailForSection function)
    // ...

    // MODIFIED: Function to generate a single thumbnail for a section
    async function generateThumbnailForSection(sectionText, index, total, useSequentialNaming = false) {
      const platform = platforms[selectedPlatform];
      const canvas = document.createElement('canvas');
      canvas.width = platform.size.width;
      canvas.height = platform.size.height;
      const ctx = canvas.getContext('2d');

      // Get consistent logo sizes for final thumbnail
      const logoSize = getLogoSize(canvas);

      // Draw background
      if (selectedImage) {
        const imgObjUrl = URL.createObjectURL(selectedImage);
        const baseImage = await loadImage(imgObjUrl, false).catch(err => { 
          throw new Error('Uploaded image could not be loaded: ' + err.message); 
        });
        
        URL.revokeObjectURL(imgObjUrl);

        // Calculate how to fit the image to canvas while maintaining aspect ratio
        const imgRatio = baseImage.width / baseImage.height;
        const canvasRatio = canvas.width / canvas.height;
        
        let drawWidth, drawHeight, offsetX, offsetY;
        
        if (imgRatio > canvasRatio) {
          // Image is wider than canvas
          drawHeight = canvas.height;
          drawWidth = baseImage.width * (canvas.height / baseImage.height);
          offsetX = (canvas.width - drawWidth) / 2;
          offsetY = 0;
        } else {
          // Image is taller than canvas
          drawWidth = canvas.width;
          drawHeight = baseImage.height * (canvas.width / baseImage.width);
          offsetX = 0;
          offsetY = (canvas.height - drawHeight) / 2;
        }
        
        // Draw the image
        ctx.drawImage(baseImage, offsetX, offsetY, drawWidth, drawHeight);
        
        // Apply brightness adjustment
        ctx.globalCompositeOperation = 'source-atop';
        ctx.fillStyle = `rgba(0, 0, 0, ${1 - brightness})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalCompositeOperation = 'source-over';
        
        // Apply enhanced vignette effect on right and bottom
        if (vignette > 0) {
          const gradientRight = ctx.createLinearGradient(canvas.width * 0.7, 0, canvas.width, 0);
          gradientRight.addColorStop(0, `rgba(0, 0, 0, 0)`);
          gradientRight.addColorStop(1, `rgba(0, 0, 0, ${vignette * 2})`);
          
          const gradientBottom = ctx.createLinearGradient(0, canvas.height * 0.7, 0, canvas.height);
          gradientBottom.addColorStop(0, `rgba(0, 0, 0, 0)`);
          gradientBottom.addColorStop(1, `rgba(0, 0, 0, ${vignette * 2})`);
          
          // Apply right vignette
          ctx.fillStyle = gradientRight;
          ctx.fillRect(canvas.width * 0.7, 0, canvas.width * 0.3, canvas.height);
          
          // Apply bottom vignette
          ctx.fillStyle = gradientBottom;
          ctx.fillRect(0, canvas.height * 0.7, canvas.width, canvas.height * 0.3);
        }
        
        // Apply cinematic effects
        applyGradientOverlay(ctx, canvas);
        applyFilmGrain(ctx, canvas);
      } else {
        // Draw gradient background if no image
        ctx.fillStyle = bgColorInput.value;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Apply brightness adjustment
        ctx.globalCompositeOperation = 'source-atop';
        ctx.fillStyle = `rgba(0, 0, 0, ${1 - brightness})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalCompositeOperation = 'source-over';
        
        // Apply enhanced vignette effect on right and bottom
        if (vignette > 0) {
          const gradientRight = ctx.createLinearGradient(canvas.width * 0.7, 0, canvas.width, 0);
          gradientRight.addColorStop(0, `rgba(0, 0, 0, 0)`);
          gradientRight.addColorStop(1, `rgba(0, 0, 0, ${vignette * 2})`);
          
          const gradientBottom = ctx.createLinearGradient(0, canvas.height * 0.7, 0, canvas.height);
          gradientBottom.addColorStop(0, `rgba(0, 0, 0, 0)`);
          gradientBottom.addColorStop(1, `rgba(0, 0, 0, ${vignette * 2})`);
          
          // Apply right vignette
          ctx.fillStyle = gradientRight;
          ctx.fillRect(canvas.width * 0.7, 0, canvas.width * 0.3, canvas.height);
          
          // Apply bottom vignette
          ctx.fillStyle = gradientBottom;
          ctx.fillRect(0, canvas.height * 0.7, canvas.width, canvas.height * 0.3);
        }
        
        // Apply cinematic effects
        applyGradientOverlay(ctx, canvas);
        applyFilmGrain(ctx, canvas);
      }

      // Draw text
      if (sectionText) {
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';

        // Calculate safe areas (consider logo areas)
        const logoAreaHeight = logoSize.platform + logoSize.margin * 2;
        const bottomAreaHeight = canvas.height * 0.10;
        const availableHeight = canvas.height - logoAreaHeight - bottomAreaHeight;
        const paddingSides = canvas.width * 0.10;
        const maxTextWidth = canvas.width - paddingSides * 2;

        // Calculate optimal font and lines
        const { fontSize, lines, lineHeight } = calculateOptimalFontSize(sectionText, maxTextWidth, availableHeight, ctx);

        const totalHeight = lines.length * lineHeight;
        const startY = logoAreaHeight + (availableHeight - totalHeight) / 2;
        const startX = paddingSides;

        // Draw text with highlighting and different sizes
        lines.forEach((line, lineIndex) => {
          let currentX = startX;
          const currentY = startY + lineIndex * lineHeight;
          
          line.forEach((part, wordIndex) => {
            // Add space between words (except first word)
            if (wordIndex > 0) {
              ctx.font = `bold ${fontSize}px 'Noto Sans Devanagari', 'Inter', sans-serif`;
              ctx.fillStyle = textColorInput.value;
              applyDropShadow(ctx, ' ', currentX, currentY, fontSize, textColorInput.value);
              currentX += ctx.measureText(' ').width;
            }
            
            // Draw word with appropriate color and font size
            ctx.font = `bold ${part.fontSize}px 'Noto Sans Devanagari', 'Inter', sans-serif`;
            ctx.fillStyle = part.highlight ? highlightColorInput.value : textColorInput.value;
            
            // Apply text effects
            applyTextGlow(ctx, part.text, currentX, currentY, part.fontSize, part.highlight ? highlightColorInput.value : textColorInput.value);
            applyDropShadow(ctx, part.text, currentX, currentY, part.fontSize, part.highlight ? highlightColorInput.value : textColorInput.value);
            
            currentX += ctx.measureText(part.text).width;
          });
        });
      }

      // Draw platform logo (top left) - CONSISTENT SIZE
      ctx.fillStyle = platform.logo.color;
      ctx.font = `900 ${logoSize.platform}px FontAwesome`;
      
      // Set the correct icon based on platform
      let iconChar;
      switch(selectedPlatform) {
        case 'youtube':
        case 'youtube-shorts': 
          iconChar = 'ï…§'; 
          break;
        case 'spotify': 
          iconChar = 'ï†¼'; 
          break;
        case 'facebook': 
          iconChar = 'ïŽž'; 
          break;
        case 'instagram':
        case 'instagram-reels':
        case 'instagram-16-9': 
          iconChar = 'ï…­'; 
          break;
        default: 
          iconChar = 'ï€¾';
      }
      
      applyTextGlow(ctx, iconChar, logoSize.margin, logoSize.margin, logoSize.platform, platform.logo.color);

      // Load and draw Vikas Jajim logo (top right) - CONSISTENT SIZE
      let logoImg = null;
      const logoSrc = uiLogoImg && uiLogoImg.src ? uiLogoImg.src : null;
      
      if (logoSrc) { 
        try { 
          logoImg = await loadImage(logoSrc, true); 
        } catch (e) { 
          console.warn('Logo failed to load', e.message); 
          logoImg = null; 
        } 
      }
      
      if (logoImg) {
        // Calculate dimensions to maintain aspect ratio
        const logoWidth = logoSize.brand;
        const logoHeight = (logoImg.height * logoWidth) / logoImg.width;
        const logoX = canvas.width - logoWidth - logoSize.margin;
        const logoY = logoSize.margin;
        
        ctx.globalAlpha = 0.9;
        ctx.drawImage(logoImg, logoX, logoY, logoWidth, logoHeight);
        ctx.globalAlpha = 1.0;
      }

      // Load and draw watermark (center)
      let watermarkImg = null;
      const watermarkSrc = uiWatermarkImg && uiWatermarkImg.src ? uiWatermarkImg.src : null;
      
      if (watermarkSrc) { 
        try { 
          watermarkImg = await loadImage(watermarkSrc, true); 
        } catch (e) { 
          console.warn('Watermark failed to load', e.message); 
          watermarkImg = null; 
        } 
      }
      
      if (watermarkImg) {
        const wmWidth = canvas.width * 0.25;
        const wmHeight = (watermarkImg.height * wmWidth) / watermarkImg.width;
        const wmX = (canvas.width - wmWidth) / 2;
        const wmY = (canvas.height - wmHeight) / 2;
        ctx.globalAlpha = 0.28;
        ctx.drawImage(watermarkImg, wmX, wmY, wmWidth, wmHeight);
        ctx.globalAlpha = 1.0;
      }

      let dataURL;
      try {
        dataURL = canvas.toDataURL('image/png');
      } catch (err) {
        console.error('toDataURL failed:', err);
        throw err;
      }
      
      // MODIFIED: Use sequential numbering for ZIP files
      let filename;
      if (useSequentialNaming) {
        filename = `${index + 1}.png`;
      } else {
        filename = generateFilename(index, total);
      }
      
      return { dataURL, filename, sectionText };
    }

    // MODIFIED: Function to generate and download multiple thumbnails
    async function generateAndDownloadThumbnails() {
      const text = textInput.value;
      if (!text && !selectedImage) { 
        alert('Please add text or upload an image'); 
        return; 
      }

      downloadBtn.disabled = true;
      updateProgress(0);

      try {
        const sections = splitIntoSections(text);
        const totalSections = sections.length;
        
        // If only one section, download as single file
        if (totalSections <= 1) {
          await generateAndDownloadSingleThumbnail();
          return;
        }
        
        // Multiple sections, create ZIP
        updateProgress(10);
        
        const zip = new JSZip();
        let successfulGenerations = 0;
        let telegramResults = [];
        
        // Generate each thumbnail
        for (let i = 0; i < totalSections; i++) {
          const section = sections[i];
          if (section.trim()) {
            try {
              updateProgress(10 + (i / totalSections) * 70);
              
              // MODIFIED: Use sequential naming for ZIP files
              const result = await generateThumbnailForSection(section, i, totalSections, true);
              
              // Add to ZIP
              const blob = await fetch(result.dataURL).then(r => r.blob());
              zip.file(result.filename, blob);
              
              successfulGenerations++;
              
              // Send to Telegram (non-blocking) - Use original filename for Telegram
              const originalResult = await generateThumbnailForSection(section, i, totalSections, false);
              setTimeout(async () => {
                try {
                  const telegramResult = await sendToTelegram(originalResult.dataURL, originalResult.sectionText, originalResult.filename);
                  telegramResults.push({ filename: originalResult.filename, success: telegramResult.success, message: telegramResult.message });
                  
                  // If all Telegram sends are done, show summary
                  if (telegramResults.length === successfulGenerations) {
                    const successfulTelegram = telegramResults.filter(r => r.success).length;
                    showTelegramStatus(`ðŸ“¦ ${successfulGenerations}/${totalSections} thumbnails generated | ðŸ“¤ ${successfulTelegram}/${successfulGenerations} sent to Telegram`, true);
                  }
                } catch (error) {
                  console.error(`Telegram sending failed for ${originalResult.filename}:`, error);
                  telegramResults.push({ filename: originalResult.filename, success: false, message: 'Failed to send' });
                }
              }, 100);
              
            } catch (error) {
              console.error(`Error generating thumbnail for section ${i + 1}:`, error);
            }
          }
        }
        
        updateProgress(85);
        
        // Generate and download ZIP
        const zipBlob = await zip.generateAsync({ type: 'blob' });
        const zipFilename = `thumbnails_${new Date().toISOString().slice(0, 10)}.zip`;
        
        saveAs(zipBlob, zipFilename);
        
        if ('vibrate' in navigator) navigator.vibrate(200);
        updateProgress(100);

        setTimeout(() => { 
          progressContainer.style.display = 'none'; 
          progressBar.style.width = '0%'; 
          downloadBtn.disabled = false; 
        }, 1000);

      } catch (error) {
        console.error('Error in processing:', error);
        alert('Error generating thumbnails â€” see console for details. ' + (error && error.message ? error.message : ''));
        progressContainer.style.display = 'none';
        progressBar.style.width = '0%';
        downloadBtn.disabled = false;
      }
    }

    // (Keep the rest of the existing JavaScript code)
    // ...
  </script>
</body>
</html>
